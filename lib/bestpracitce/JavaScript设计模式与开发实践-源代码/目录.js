目录  · · · · · ·
第一部分　基础知识
第1章　面向对象的JavaScript
1.1 动态类型语言和鸭子类型　　2
1.2 多态　　4
1.3 封装　　12
1.4 原型模式和基于原型继承的JavaScript对象系统　　14
第2章　this、call和apply
2.1 this　　24
2.2 call和apply　　29
第3章　闭包和高阶函数
3.1 闭包 35
3.2 高阶函数　　44
3.3 小结　　58
第二部分 设计模式
第4章　单例模式
4.1 实现单例模式　　60
4.2 透明的单例模式　　61
4.3 用代理实现单例模式　　62
4.4 JavaScript中的单例模式　　63
4.5 惰性单例　　65
4.6 通用的惰性单例　　68
4.7 小结　　70
第5章　策略模式
5.1 使用策略模式计算奖金　　72
5.2 JavaScript 版本的策略模式　　75
5.3 多态在策略模式中的体现　　76
5.4 使用策略模式实现缓动动画　　76
5.5 更广义的“算法”　　80
5.6 表单校验　　80
5.7 策略模式的优缺点　　86
5.8 一等函数对象与策略模式　　86
5.9 小结　　87
第6章　代理模式
6.1 第一个例子——小明追MM的故事　　88
6.2 保护代理和虚拟代理　　91
6.3 虚拟代理实现图片预加载　　91
6.4 代理的意义　　93
6.5 代理和本体接口的一致性　　94
6.6 虚拟代理合并HTTP 请求　　95
6.7 虚拟代理在惰性加载中的应用　　97
6.8 缓存代理　　99
6.9 用高阶函数动态创建代理　　100
6.10 其他代理模式　　101
6.11 小结　　102
第7章　迭代器模式
7.1 jQuery 中的迭代器　　103
7.2 实现自己的迭代器　　104
7.3 内部迭代器和外部迭代器　　104
7.4 迭代类数组对象和字面量对象　　106
7.5 倒序迭代器　　106
7.6 中止迭代器　　107
7.7 迭代器模式的应用举例　　107
7.8 小结　　109
第8章　发布—订阅模式
8.1 现实中的发布—订阅模式　　110
8.2 发布—订阅模式的作用　　110
8.3 DOM 事件　　111
8.4 自定义事件　　112
8.5 发布—订阅模式的通用实现　　113
8.6 取消订阅的事件　　115
8.7 真实的例子——网站登录　　115
8.8 全局的发布—订阅对象　　117
8.9 模块间通信　　119
8.10 必须先订阅再发布吗　　120
8.11 全局事件的命名冲突　　121
8.12 JavaScript实现发布—订阅模式的便利性　　124
8.13 小结　　124
第9章　命令模式
9.1 命令模式的用途　　125
9.2 命令模式的例子——菜单程序　　126
9.3 JavaScript中的命令模式　　128
9.4 撤销命令　　130
9.5 撤消和重做　　132
9.6 命令队列　　134
9.7 宏命令　　134
9.8 智能命令与傻瓜命令　　135
9.9 小结　　136
第10章　组合模式
10.1 回顾宏命令　　138
10.2 组合模式的用途　　139
10.3 请求在树中传递的过程　　139
10.4 更强大的宏命令　　140
10.5 抽象类在组合模式中的作用　　143
10.6 透明性带来的安全问题　　144
10.7 组合模式的例子——扫描文件夹　　145
10.8 一些值得注意的地方　　147
10.9 引用父对象　　148
10.10 何时使用组合模式　　150
10.11 小结　　150
第11章　模板方法模式
11.1 模板方法模式的定义和组成　　151
11.2 第一个例子——Coffee or Tea　　151
11.3 抽象类　　156
11.4 模板方法模式的使用场景　　159
11.5 钩子方法　　160
11.6 好莱坞原则　　162
11.7 真的需要“继承”吗　　162
11.8 小结　　164
第12章　享元模式
12.1 初识享元模式　　165
12.2 内部状态与外部状态　　166
12.3 享元模式的通用结构　　167
12.4 文件上传的例子　　167
12.5 享元模式的适用性　　173
12.6 再谈内部状态和外部状态　　173
12.7 对象池　　175
12.8 小结　　178
第13章　职责链模式
13.1 现实中的职责链模式　　179
13.2 实际开发中的职责链模式　　180
13.3 用职责链模式重构代码　　181
13.4 灵活可拆分的职责链节点　　183
13.5 异步的职责链　　184
13.6 职责链模式的优缺点　　185
13.7 用AOP 实现职责链　　186
13.8 用职责链模式获取文件上传对象　　187
13.9 小结　　188
第14章　中介者模式
14.1 现实中的中介者　　190
14.2 中介者模式的例子——泡泡堂游戏　　191
14.3 中介者模式的例子——购买商品　　199
14.4 小结　　207
第15章　装饰者模式
15.1 模拟传统面向对象语言的装饰者模式　　210
15.2 装饰者也是包装器　　211
15.3 回到JavaScript 的装饰者　　212
15.4 装饰函数　　212
15.5 用AOP 装饰函数　　214
15.6 AOP 的应用实例　　216
15.7 装饰者模式和代理模式　　222
15.8 小结　　223
第16章　状态模式
16.1 初识状态模式　　224
16.2 状态模式的定义　　230
16.3 状态模式的通用结构　　230
16.4 缺少抽象类的变通方式　　　231
16.5 另一个状态模式示例——文件上传　　232
16.6 状态模式的优缺点　　241
16.7 状态模式中的性能优化点　　241
16.8 状态模式和策略模式的关系　　241
16.9 JavaScript版本的状态机　　242
16.10 表驱动的有限状态机　　244
16.11 实际项目中的其他状态机　　245
16.12 小结　　245
第17章　适配器模式
17.1 现实中的适配器　　246
17.2 适配器模式的应用　　247
17.3 小结　　250
第三部分 设计原则和编程技巧
第18章　单一职责原则
18.1 设计模式中的SRP原则　　252
18.2 何时应该分离职责　　256
18.3 违反SRP原则　　256
18.4 SRP 原则的优缺点　　257
第19章　最少知识原则
19.1 减少对象之间的联系　　258
19.2 设计模式中的LKP原则　　259
19.3 封装在LKP 原则中的体现　　261
第20章　开放-封闭原则
20.1 扩展window.onload函数　　263
20.2 开放和封闭　　264
20.3 用对象的多态性消除条件分支　　265
20.4 找出变化的地方　　266
20.5 设计模式中的开放—封闭原则　　268
20.6 开放—封闭原则的相对性　　270
20.7 接受第一次愚弄　　270
第21章　接口和面向接口编程
21.1 回到Java的抽象类　　271
21.2 interface　　276
21.3 JavaScript 语言是否需要抽象类和interface　　275
21.4 用鸭子类型进行接口检查　　277
21.5 用TypeScript 编写基于interface的命令模式　　278
第22章　代码重构
22.1 提炼函数　　282
22.2 合并重复的条件片段　　283
22.3 把条件分支语句提炼成函数　　284
22.4 合理使用循环　　285
22.5 提前让函数退出代替嵌套条件分支　　285
22.6 传递对象参数代替过长的参数列表　　286
22.7 尽量减少参数数量　　287
22.8 少用三目运算符　　288
22.9 合理使用链式调用　　288
22.10 分解大型类　　289
22.11 用return退出多重循环　　290
参考文献　　293